#!/usr/bin/env python3
"""
Performance optimizations for OpenWRTInvasion exploit scripts.
Provides configurable timeouts, parallel connection checking, and session pooling.
"""

import asyncio
import socket
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Optional, Tuple
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class ExploitSettings:
    """Centralized configuration for exploit performance settings."""
    
    # Default settings for V1 (more aggressive)
    V1_DEFAULTS = {
        'timeout': 1.0,
        'delay': 0.25,
        'retries': 2,
        'connect_timeout': 1.0,
        'read_timeout': 3.0
    }
    
    # Default settings for V2 (more conservative)  
    V2_DEFAULTS = {
        'timeout': 5.0,
        'delay': 1.0,
        'retries': 3,
        'connect_timeout': 2.0,
        'read_timeout': 5.0
    }
    
    def __init__(self, version='v1', **overrides):
        """Initialize settings with defaults for specified version."""
        defaults = self.V1_DEFAULTS if version == 'v1' else self.V2_DEFAULTS
        
        # Apply defaults then overrides
        for key, value in defaults.items():
            setattr(self, key, value)
        
        for key, value in overrides.items():
            setattr(self, key, value)


class OptimizedSession:
    """HTTP session with connection pooling and retry logic."""
    
    def __init__(self, settings: ExploitSettings):
        self.settings = settings
        self.session = requests.Session()
        
        # Configure retry strategy
        retry_strategy = Retry(
            total=settings.retries,
            status_forcelist=[429, 500, 502, 503, 504],
            backoff_factor=0.3
        )
        
        # Configure adapter with connection pooling
        adapter = HTTPAdapter(
            pool_maxsize=10,
            pool_block=True,
            max_retries=retry_strategy
        )
        
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    
    def get(self, url, **kwargs):
        """Perform GET request with optimized timeouts."""
        timeout = kwargs.pop('timeout', (self.settings.connect_timeout, self.settings.read_timeout))
        return self.session.get(url, timeout=timeout, **kwargs)
    
    def post(self, url, **kwargs):
        """Perform POST request with optimized timeouts."""
        timeout = kwargs.pop('timeout', (self.settings.connect_timeout, self.settings.read_timeout))
        return self.session.post(url, timeout=timeout, **kwargs)


class FastPortChecker:
    """Optimized port checking with parallel connections and smart timeouts."""
    
    def __init__(self, settings: ExploitSettings):
        self.settings = settings
    
    def check_port_sync(self, host: str, port: int, timeout: float = None) -> bool:
        """Check single port with non-blocking socket."""
        if timeout is None:
            timeout = self.settings.timeout
            
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        
        try:
            result = sock.connect_ex((host, port))
            return result == 0
        except (socket.timeout, socket.error):
            return False
        finally:
            sock.close()
    
    def check_ports_parallel(self, host: str, ports: List[int], max_workers: int = 3) -> dict:
        """Check multiple ports in parallel using threads."""
        results = {}
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all port checks
            future_to_port = {
                executor.submit(self.check_port_sync, host, port): port 
                for port in ports
            }
            
            # Collect results as they complete
            for future in as_completed(future_to_port):
                port = future_to_port[future]
                try:
                    results[port] = future.result()
                except Exception:
                    results[port] = False
        
        return results
    
    def wait_for_service(self, host: str, ports: List[int], max_wait: float = 15.0) -> Optional[int]:
        """Wait for any service to come online with exponential backoff."""
        start_time = time.time()
        backoff = 0.3  # Start with 300ms
        
        while time.time() - start_time < max_wait:
            # Check all ports in parallel
            results = self.check_ports_parallel(host, ports)
            
            # Return first available port
            for port, is_open in results.items():
                if is_open:
                    return port
            
            # Exponential backoff, cap at 2 seconds
            time.sleep(min(backoff, 2.0))
            backoff *= 1.5
        
        return None


# Async version for Python 3.7+
class AsyncPortChecker:
    """Async port checker for even better performance."""
    
    def __init__(self, settings: ExploitSettings):
        self.settings = settings
    
    async def check_port_async(self, host: str, port: int) -> bool:
        """Check single port asynchronously."""
        try:
            future = asyncio.open_connection(host, port)
            reader, writer = await asyncio.wait_for(future, timeout=self.settings.timeout)
            writer.close()
            await writer.wait_closed()
            return True
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return False
    
    async def check_ports_async(self, host: str, ports: List[int]) -> dict:
        """Check multiple ports concurrently."""
        tasks = [self.check_port_async(host, port) for port in ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        return {
            port: result if isinstance(result, bool) else False 
            for port, result in zip(ports, results)
        }
    
    async def wait_for_service_async(self, host: str, ports: List[int], max_wait: float = 15.0) -> Optional[int]:
        """Async wait for service with smart backoff."""
        start_time = time.time()
        backoff = 0.3
        
        while time.time() - start_time < max_wait:
            results = await self.check_ports_async(host, ports)
            
            for port, is_open in results.items():
                if is_open:
                    return port
            
            await asyncio.sleep(min(backoff, 2.0))
            backoff *= 1.5
        
        return None


def get_port_checker(settings: ExploitSettings, use_async: bool = True):
    """Factory function to get appropriate port checker."""
    try:
        if use_async and hasattr(asyncio, 'run'):  # Python 3.7+
            return AsyncPortChecker(settings)
    except ImportError:
        pass
    
    return FastPortChecker(settings)


# Utility functions for backward compatibility
def legacy_check_host(ip: str, port: int, settings: ExploitSettings = None) -> bool:
    """Drop-in replacement for original checkHost function."""
    if settings is None:
        settings = ExploitSettings()
    
    checker = FastPortChecker(settings)
    
    for attempt in range(settings.retries):
        if checker.check_port_sync(ip, port):
            return True
        if attempt < settings.retries - 1:  # Don't sleep on last attempt
            time.sleep(settings.delay)
    
    return False


def fast_service_check(ip: str, ports: List[int] = None, settings: ExploitSettings = None) -> Optional[int]:
    """Fast service availability check returning first available port."""
    if ports is None:
        ports = [22, 23, 21]  # SSH, Telnet, FTP
    
    if settings is None:
        settings = ExploitSettings()
    
    try:
        # Try async first
        if hasattr(asyncio, 'run'):
            checker = AsyncPortChecker(settings)
            return asyncio.run(checker.wait_for_service_async(ip, ports))
    except (ImportError, RuntimeError):
        pass
    
    # Fallback to threaded approach
    checker = FastPortChecker(settings)
    return checker.wait_for_service(ip, ports)


if __name__ == "__main__":
    # Quick test/benchmark
    settings = ExploitSettings('v2')
    print(f"Testing with settings: timeout={settings.timeout}s, retries={settings.retries}")
    
    # Test local loopback
    start = time.time()
    result = fast_service_check("127.0.0.1", [22, 80, 443])
    elapsed = time.time() - start
    
    print(f"Port check completed in {elapsed:.2f}s, result: {result}")